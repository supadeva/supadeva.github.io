<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SUPADEVA</title>
<style>
  * { margin: 0; padding: 0; }
  body { background: #000; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');
let w, h, t = 0;

function resize() {
  w = c.width = innerWidth;
  h = c.height = innerHeight;
}
resize();
addEventListener('resize', resize);

// Precompute sine table
const SIN = new Float32Array(2048);
for (let i = 0; i < 2048; i++) SIN[i] = Math.sin(i * Math.PI * 2 / 2048);
function sin(v) { return SIN[((v % 2048) + 2048) % 2048 | 0]; }
function cos(v) { return SIN[(((v + 512) % 2048) + 2048) % 2048 | 0]; }

// Star field
const STARS = 300;
const sx = new Float32Array(STARS), sy = new Float32Array(STARS), sz = new Float32Array(STARS);
for (let i = 0; i < STARS; i++) {
  sx[i] = (Math.random() - 0.5) * 2000;
  sy[i] = (Math.random() - 0.5) * 2000;
  sz[i] = Math.random() * 1000;
}

function drawStars() {
  for (let i = 0; i < STARS; i++) {
    sz[i] -= 3;
    if (sz[i] < 1) { sz[i] = 1000; sx[i] = (Math.random() - 0.5) * 2000; sy[i] = (Math.random() - 0.5) * 2000; }
    // Barrel rotation
    const angle = t * 0.01;
    const rx = sx[i] * Math.cos(angle) - sy[i] * Math.sin(angle);
    const ry = sx[i] * Math.sin(angle) + sy[i] * Math.cos(angle);
    const px = rx / sz[i] * 300 + w / 2;
    const py = ry / sz[i] * 300 + h / 2;
    const br = Math.min(255, (1 - sz[i] / 1000) * 255) | 0;
    const size = (1 - sz[i] / 1000) * 8;
    ctx.fillStyle = `rgb(${br},${br},${br + 40 | 0})`;
    ctx.fillRect(px | 0, py | 0, size | 0, size | 0);
  }
}

// Copper bars
function drawCopper() {
  const barY = h * 0.15;
  for (let y = 0; y < 6; y++) {
    const yy = barY + y * 3;
    const r = 100 + sin(t * 3 + y * 100) * 80 | 0;
    const g = 60 + sin(t * 2.5 + y * 120 + 300) * 60 | 0;
    const b = 160 + sin(t * 2 + y * 80 + 600) * 95 | 0;
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(0, yy, w, 3);
  }
  const barY2 = h * 0.78;
  for (let y = 0; y < 6; y++) {
    const yy = barY2 + y * 3;
    const r = 160 + sin(t * 2 + y * 80 + 200) * 95 | 0;
    const g = 80 + sin(t * 3 + y * 100 + 500) * 70 | 0;
    const b = 120 + sin(t * 2.5 + y * 120) * 80 | 0;
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(0, yy, w, 3);
  }
}

// Plasma background (low res for perf)
const plasmaScale = 12;
const plasmaCanvas = document.createElement('canvas');
const plasmaCtx = plasmaCanvas.getContext('2d');
function drawPlasma() {
  const pw = (w / plasmaScale) | 0;
  const ph = (h / plasmaScale) | 0;
  plasmaCanvas.width = pw;
  plasmaCanvas.height = ph;
  const imgData = plasmaCtx.createImageData(pw, ph);
  const d = imgData.data;
  for (let y = 0; y < ph; y++) {
    for (let x = 0; x < pw; x++) {
      const v1 = sin(x * 8 + t * 2);
      const v2 = sin(y * 6 + t * 3);
      const v3 = sin((x * 5 + y * 5) + t * 1.5);
      const v4 = sin(Math.sqrt(x * x + y * y) * 4 + t * 2.5);
      const v = (v1 + v2 + v3 + v4) * 0.25;
      const i = (y * pw + x) * 4;
      d[i]     = (v * 70 + 50) | 0;
      d[i + 1] = (v * 40 + 25) | 0;
      d[i + 2] = (v * 80 + 60) | 0;
      d[i + 3] = 255;
    }
  }
  plasmaCtx.putImageData(imgData, 0, 0);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(plasmaCanvas, 0, 0, pw, ph, 0, 0, w, h);
}

// Big chunky pixel font for SUPADEVA
const FONT = {
  S: [0x7C,0xC0,0xC0,0x78,0x0C,0x0C,0xF8],
  U: [0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x78],
  P: [0xF8,0xCC,0xCC,0xF8,0xC0,0xC0,0xC0],
  A: [0x30,0x78,0xCC,0xCC,0xFC,0xCC,0xCC],
  D: [0xF0,0xD8,0xCC,0xCC,0xCC,0xD8,0xF0],
  E: [0xFC,0xC0,0xC0,0xF0,0xC0,0xC0,0xFC],
  V: [0xCC,0xCC,0xCC,0xCC,0xCC,0x78,0x30],
  '*': [0x00,0x24,0x18,0x7E,0x18,0x24,0x00],
};

function drawChar(ch, ox, oy, size, r, g, b, xScale) {
  const rows = FONT[ch];
  if (!rows) return;
  const sw = size * (xScale || 1);
  for (let y = 0; y < 7; y++) {
    let bits = rows[y];
    for (let x = 0; x < 8; x++) {
      if (bits & (0x80 >> x)) {
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(ox + x * sw, oy + y * size, sw, size);
        ctx.fillStyle = `rgba(${r},${g},${b},0.3)`;
        ctx.fillRect(ox + x * sw - 1, oy + y * size - 1, sw + 2, size + 2);
      }
    }
  }
}

function drawLogo() {
  const lines = ["SUP", "ADE", "VA*"];
  const charW = 9;
  const size = Math.floor(w * 0.3 / (charW * 3));
  const xScale = 1;
  const lineH = 8 * size;
  const totalH = lines.length * lineH;
  const totalChars = 9; // SUP ADE VA*
  const typeSpeed = 12; // frames per character
  const holdTime = 120; // frames to hold after complete
  const cycleLen = totalChars * typeSpeed + holdTime + totalChars * typeSpeed;
  const phase = t % cycleLen;
  
  let charsVisible;
  if (phase < totalChars * typeSpeed) {
    // typing in
    charsVisible = Math.floor(phase / typeSpeed);
  } else if (phase < totalChars * typeSpeed + holdTime) {
    // holding
    charsVisible = totalChars;
  } else {
    // typing out (reverse)
    const removePhase = phase - totalChars * typeSpeed - holdTime;
    charsVisible = totalChars - Math.floor(removePhase / typeSpeed) - 1;
  }

  // slow rotate & zoom
  const angle = Math.sin(t * 0.008) * 0.15;
  const zoom = 1 + Math.sin(t * 0.005) * 0.08;

  ctx.save();
  ctx.translate(w / 2, h / 2);
  ctx.rotate(angle);
  ctx.scale(zoom, zoom);
  ctx.translate(-w / 2, -h / 2);

  const baseY = h / 2 - totalH / 2;
  let charIndex = 0;
  for (let l = 0; l < lines.length; l++) {
    const text = lines[l];
    const totalW = text.length * charW * size * xScale;
    const baseX = (w - totalW) / 2;
    for (let i = 0; i < text.length; i++) {
      if (charIndex >= charsVisible) { ctx.restore(); return; }
      const ch = text[i];
      const wobbleY = sin(t * 5 + i * 180) * size * 2;
      const ox = baseX + i * charW * size * xScale;
      const oy = baseY + l * lineH + wobbleY;
      drawChar(ch, ox, oy, size, 255, 255, 255, xScale);
      charIndex++;
    }
  }
  ctx.restore();
}

// Scroll text
const scrollText = "     SUPADEVA --- THE CODE GROUP --- GREETINGS TO ALL CODERS OUT THERE --- KEEP HACKING --- 2026 ---          ";
let scrollX = w;

function drawScroller() {
  const scrollY = h * 0.88;
  ctx.font = 'bold 20px monospace';
  const charW = 14;

  for (let i = 0; i < scrollText.length; i++) {
    const x = scrollX + i * charW;
    if (x < -charW || x > w + charW) continue;
    const wobble = sin(t * 6 + i * 60) * 8;
    const r = 230 + sin(t * 3 + i * 40) * 25 | 0;
    const g = 210 + sin(t * 2 + i * 50 + 300) * 45 | 0;
    const b = 255;
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillText(scrollText[i], x, scrollY + wobble);
  }
  scrollX -= 2;
  if (scrollX < -scrollText.length * charW) scrollX = w;
}

// Raster bars behind logo
function drawRasterBars() {
  const cy = h / 2;
  for (let i = -40; i < 40; i++) {
    const y = cy + i * 3;
    const intensity = 1 - Math.abs(i) / 40;
    const r = sin(t * 2 + i * 30) * 30 * intensity | 0;
    const g = sin(t * 2.5 + i * 40 + 200) * 20 * intensity | 0;
    const b = sin(t * 3 + i * 50 + 500) * 40 * intensity | 0;
    ctx.fillStyle = `rgba(${80 + r},${40 + g},${90 + b},${intensity * 0.3})`;
    ctx.fillRect(0, y, w, 3);
  }
}

// Bouncing rubber ducks
const ducks = [];
// 10x9 rubber bath duck: 1=body(yellow), 2=beak(orange), 3=eye(black), 4=wing(darker yellow)
const DUCK_SPRITE = [
  [0,0,0,1,1,1,0,0,0,0],
  [0,0,1,1,3,1,0,0,0,0],
  [0,0,1,1,1,2,2,0,0,0],
  [0,1,1,1,1,1,0,0,0,0],
  [1,1,1,4,4,1,1,1,0,0],
  [1,1,4,4,4,1,1,1,1,0],
  [0,1,1,1,1,1,1,1,1,1],
  [0,0,1,1,1,1,1,1,1,0],
  [0,0,0,0,0,0,0,0,0,0],
];
const DUCK_COLORS = { 1: '#FFD700', 2: '#FF8C00', 3: '#000', 4: '#DAA520' };

function spawnDuck() {
  const goRight = Math.random() < 0.5;
  ducks.push({
    x: goRight ? -60 : w + 60,
    y: Math.random() * (h * 0.6) + h * 0.1,
    vx: (1 + Math.random() * 1.5) * (goRight ? 1 : -1),
    vy: -(3 + Math.random() * 2), gravity: 0.15,
    bobPhase: Math.random() * 2000,
    size: 5 + Math.random() * 3 | 0,
  });
}

function drawDucks() {
  if (t % 180 === 0 && ducks.length < 12) spawnDuck();

  for (let i = ducks.length - 1; i >= 0; i--) {
    const d = ducks[i];
    d.x += d.vx;
    d.vy += d.gravity;
    d.y += d.vy;
    const dh = 9 * d.size;
    if (d.y + dh > h) { d.y = h - dh; d.vy *= -0.75; }
    // Remove when off screen left or right
    if (d.x > w + 80 || d.x < -80) { ducks.splice(i, 1); continue; }
    const bobY = sin(t * 4 + d.bobPhase) * 4;
    const flip = d.vx < 0;
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 10; c++) {
        const v = DUCK_SPRITE[r][flip ? 9 - c : c];
        if (v) {
          ctx.fillStyle = DUCK_COLORS[v];
          ctx.fillRect(d.x + c * d.size, d.y + r * d.size + bobY, d.size, d.size);
        }
      }
    }
  }
}

// --- 8-bit music engine ---
let audioStarted = false;
let muted = false;
let masterGain = null;

function toggleAudio() {
  if (!audioStarted) {
    startAudio();
    return;
  }
  muted = !muted;
  masterGain.gain.value = muted ? 0 : 0.35;
}

function startAudio() {
  if (audioStarted) return;
  audioStarted = true;
  const ac = new (window.AudioContext || window.webkitAudioContext)();
  const master = ac.createGain();
  master.gain.value = 0.35;
  master.connect(ac.destination);
  masterGain = master;

  const noteFreq = n => 440 * Math.pow(2, (n - 69) / 12);
  const bpm = 140;
  const step = 60 / bpm / 4;

  // Acid bass (square through filter) - A minor
  const bass = [
    33,-1,-1,33, -1,33,45,-1, 33,-1,36,-1, 33,33,-1,45,
    36,-1,-1,36, -1,36,48,-1, 38,-1,36,-1, 33,33,-1,45,
  ];
  // Stab chords (offbeat minor hits)
  const stab = [
    -1,-1,1,-1, -1,-1,1,-1, -1,-1,1,-1, -1,-1,1,-1,
    -1,-1,2,-1, -1,-1,2,-1, -1,-1,1,-1, -1,-1,1,-1,
  ];
  const stabChords = [[57,60,64],[60,64,67]]; // Am, Cm
  // Drums: 1=kick, 2=open hh, 3=closed hh, 4=clap
  const drums = [
    1,0,3,2, 1,0,3,2, 1,0,3,2, 1,0,3,2,
    1,0,3,2, 1,0,3,2, 1,3,1,3, 4,0,3,2,
  ];

  const patLen = 32;
  const loopDur = patLen * step;

  // Acid filter for bass
  const acidFilter = ac.createBiquadFilter();
  acidFilter.type = 'lowpass';
  acidFilter.Q.value = 12;
  acidFilter.connect(master);

  function playBass(freq, start, dur) {
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = 'sawtooth';
    o.frequency.value = freq;
    g.gain.setValueAtTime(0.4, start);
    g.gain.exponentialRampToValueAtTime(0.001, start + dur);
    // Filter sweep per note
    acidFilter.frequency.setValueAtTime(300, start);
    acidFilter.frequency.exponentialRampToValueAtTime(2500, start + dur * 0.3);
    acidFilter.frequency.exponentialRampToValueAtTime(300, start + dur);
    o.connect(g);
    g.connect(acidFilter);
    o.start(start);
    o.stop(start + dur + 0.01);
  }

  function playNote(freq, start, dur, type, gain) {
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.setValueAtTime(gain, start);
    g.gain.exponentialRampToValueAtTime(0.001, start + dur);
    o.connect(g);
    g.connect(master);
    o.start(start);
    o.stop(start + dur + 0.01);
  }

  function playNoise(start, dur, gain) {
    const buf = ac.createBuffer(1, ac.sampleRate * dur | 0, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
    const s = ac.createBufferSource();
    s.buffer = buf;
    const g = ac.createGain();
    g.gain.setValueAtTime(gain, start);
    g.gain.exponentialRampToValueAtTime(0.001, start + dur);
    s.connect(g);
    g.connect(master);
    s.start(start);
    s.stop(start + dur);
  }

  function scheduleLoop(loopStart) {
    for (let i = 0; i < patLen; i++) {
      const t0 = loopStart + i * step;

      // Acid bass
      if (bass[i] > 0) playBass(noteFreq(bass[i]), t0, step * 0.8);

      // Stab chords
      if (stab[i] > 0) {
        const chord = stabChords[stab[i] - 1];
        for (const n of chord) playNote(noteFreq(n), t0, step * 0.3, 'square', 0.08);
      }

      // Drums
      if (drums[i] === 1) { // kick
        playNote(45, t0, 0.25, 'sine', 0.6);
        playNote(90, t0, 0.03, 'sine', 0.3);
      } else if (drums[i] === 4) { // clap
        playNoise(t0, 0.12, 0.3);
      }
      if (drums[i] === 2) { // open hh
        playNoise(t0, 0.1, 0.12);
      } else if (drums[i] === 3) { // closed hh
        playNoise(t0, 0.03, 0.1);
      }
    }
  }

  let nextLoop = ac.currentTime + 0.05;
  function scheduler() {
    while (nextLoop < ac.currentTime + 0.5) {
      scheduleLoop(nextLoop);
      nextLoop += loopDur;
    }
    setTimeout(scheduler, 200);
  }
  scheduler();
}

document.addEventListener('click', toggleAudio);
document.addEventListener('keydown', toggleAudio, { once: true });

function frame() {
  t++;
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, w, h);

  drawPlasma();
  drawStars();
  drawCopper();
  drawRasterBars();
  drawLogo();
  drawDucks();
  drawScroller();

  if (!audioStarted || muted) {
    ctx.save();
    ctx.translate(80, 40);
    ctx.rotate(Math.sin(t * 0.03) * 0.3);
    ctx.font = '12px monospace';
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.fillText(audioStarted ? 'click for tunes' : 'click for tunes', 0, 0);
    ctx.restore();
  }

  requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>
