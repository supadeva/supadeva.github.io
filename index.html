<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SUPADEVA</title>
<style>
  * { margin: 0; padding: 0; }
  body { background: #000; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');
let w, h, t = 0;

function resize() {
  w = c.width = innerWidth;
  h = c.height = innerHeight;
}
resize();
addEventListener('resize', resize);

// Precompute sine table
const SIN = new Float32Array(2048);
for (let i = 0; i < 2048; i++) SIN[i] = Math.sin(i * Math.PI * 2 / 2048);
function sin(v) { return SIN[((v % 2048) + 2048) % 2048 | 0]; }
function cos(v) { return SIN[(((v + 512) % 2048) + 2048) % 2048 | 0]; }

// Star field
const STARS = 300;
const sx = new Float32Array(STARS), sy = new Float32Array(STARS), sz = new Float32Array(STARS);
for (let i = 0; i < STARS; i++) {
  sx[i] = (Math.random() - 0.5) * 2000;
  sy[i] = (Math.random() - 0.5) * 2000;
  sz[i] = Math.random() * 1000;
}

function drawStars() {
  for (let i = 0; i < STARS; i++) {
    sz[i] -= 3;
    if (sz[i] < 1) { sz[i] = 1000; sx[i] = (Math.random() - 0.5) * 2000; sy[i] = (Math.random() - 0.5) * 2000; }
    // Barrel rotation
    const angle = t * 0.01;
    const rx = sx[i] * Math.cos(angle) - sy[i] * Math.sin(angle);
    const ry = sx[i] * Math.sin(angle) + sy[i] * Math.cos(angle);
    const px = rx / sz[i] * 300 + w / 2;
    const py = ry / sz[i] * 300 + h / 2;
    const br = Math.min(255, (1 - sz[i] / 1000) * 255) | 0;
    const size = (1 - sz[i] / 1000) * 8;
    ctx.fillStyle = `rgb(${br},${br},${br + 40 | 0})`;
    ctx.fillRect(px | 0, py | 0, size | 0, size | 0);
  }
}

// Copper bars
function drawCopper() {
  const barY = h * 0.15;
  for (let y = 0; y < 6; y++) {
    const yy = barY + y * 3;
    const r = 100 + sin(t * 3 + y * 100) * 80 | 0;
    const g = 60 + sin(t * 2.5 + y * 120 + 300) * 60 | 0;
    const b = 160 + sin(t * 2 + y * 80 + 600) * 95 | 0;
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(0, yy, w, 3);
  }
  const barY2 = h * 0.78;
  for (let y = 0; y < 6; y++) {
    const yy = barY2 + y * 3;
    const r = 160 + sin(t * 2 + y * 80 + 200) * 95 | 0;
    const g = 80 + sin(t * 3 + y * 100 + 500) * 70 | 0;
    const b = 120 + sin(t * 2.5 + y * 120) * 80 | 0;
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(0, yy, w, 3);
  }
}

// Plasma background (low res for perf)
const plasmaScale = 12;
const plasmaCanvas = document.createElement('canvas');
const plasmaCtx = plasmaCanvas.getContext('2d');
function drawPlasma() {
  const pw = (w / plasmaScale) | 0;
  const ph = (h / plasmaScale) | 0;
  plasmaCanvas.width = pw;
  plasmaCanvas.height = ph;
  const imgData = plasmaCtx.createImageData(pw, ph);
  const d = imgData.data;
  for (let y = 0; y < ph; y++) {
    for (let x = 0; x < pw; x++) {
      const v1 = sin(x * 8 + t * 2);
      const v2 = sin(y * 6 + t * 3);
      const v3 = sin((x * 5 + y * 5) + t * 1.5);
      const v4 = sin(Math.sqrt(x * x + y * y) * 4 + t * 2.5);
      const v = (v1 + v2 + v3 + v4) * 0.25;
      const i = (y * pw + x) * 4;
      d[i]     = (v * 70 + 50) | 0;
      d[i + 1] = (v * 40 + 25) | 0;
      d[i + 2] = (v * 80 + 60) | 0;
      d[i + 3] = 255;
    }
  }
  plasmaCtx.putImageData(imgData, 0, 0);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(plasmaCanvas, 0, 0, pw, ph, 0, 0, w, h);
}

// Big chunky pixel font for SUPADEVA
const FONT = {
  S: [0x7C,0xC0,0xC0,0x78,0x0C,0x0C,0xF8],
  U: [0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x78],
  P: [0xF8,0xCC,0xCC,0xF8,0xC0,0xC0,0xC0],
  A: [0x30,0x78,0xCC,0xCC,0xFC,0xCC,0xCC],
  D: [0xF0,0xD8,0xCC,0xCC,0xCC,0xD8,0xF0],
  E: [0xFC,0xC0,0xC0,0xF0,0xC0,0xC0,0xFC],
  V: [0xCC,0xCC,0xCC,0xCC,0xCC,0x78,0x30],
  '*': [0x00,0x24,0x18,0x7E,0x18,0x24,0x00],
};

function drawChar(ch, ox, oy, size, r, g, b, xScale) {
  const rows = FONT[ch];
  if (!rows) return;
  const sw = size * (xScale || 1);
  for (let y = 0; y < 7; y++) {
    let bits = rows[y];
    for (let x = 0; x < 8; x++) {
      if (bits & (0x80 >> x)) {
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(ox + x * sw, oy + y * size, sw, size);
        ctx.fillStyle = `rgba(${r},${g},${b},0.3)`;
        ctx.fillRect(ox + x * sw - 1, oy + y * size - 1, sw + 2, size + 2);
      }
    }
  }
}

function drawLogo() {
  const lines = ["SUP", "ADE", "VA*"];
  const charW = 9;
  const size = Math.floor(w * 0.3 / (charW * 3));
  const xScale = 1;
  const lineH = 8 * size;
  const totalH = lines.length * lineH;
  const totalChars = 9; // SUP ADE VA*
  const typeSpeed = 12; // frames per character
  const holdTime = 120; // frames to hold after complete
  const cycleLen = totalChars * typeSpeed + holdTime + totalChars * typeSpeed;
  const phase = t % cycleLen;
  
  let charsVisible;
  if (phase < totalChars * typeSpeed) {
    // typing in
    charsVisible = Math.floor(phase / typeSpeed);
  } else if (phase < totalChars * typeSpeed + holdTime) {
    // holding
    charsVisible = totalChars;
  } else {
    // typing out (reverse)
    const removePhase = phase - totalChars * typeSpeed - holdTime;
    charsVisible = totalChars - Math.floor(removePhase / typeSpeed) - 1;
  }

  // slow rotate & zoom
  const angle = Math.sin(t * 0.008) * 0.15;
  const zoom = 1 + Math.sin(t * 0.005) * 0.08;

  ctx.save();
  ctx.translate(w / 2, h / 2);
  ctx.rotate(angle);
  ctx.scale(zoom, zoom);
  ctx.translate(-w / 2, -h / 2);

  const baseY = h / 2 - totalH / 2;
  let charIndex = 0;
  for (let l = 0; l < lines.length; l++) {
    const text = lines[l];
    const totalW = text.length * charW * size * xScale;
    const baseX = (w - totalW) / 2;
    for (let i = 0; i < text.length; i++) {
      if (charIndex >= charsVisible) { ctx.restore(); return; }
      const ch = text[i];
      const wobbleY = sin(t * 5 + i * 180) * size * 2;
      const ox = baseX + i * charW * size * xScale;
      const oy = baseY + l * lineH + wobbleY;
      drawChar(ch, ox, oy, size, 255, 255, 255, xScale);
      charIndex++;
    }
  }
  ctx.restore();
}

// Scroll text
const scrollText = "     SUPADEVA --- THE CODE GROUP --- GREETINGS TO ALL CODERS OUT THERE --- KEEP HACKING --- 2026 ---          ";
let scrollX = w;

function drawScroller() {
  const scrollY = h * 0.88;
  ctx.font = 'bold 20px monospace';
  const charW = 14;

  for (let i = 0; i < scrollText.length; i++) {
    const x = scrollX + i * charW;
    if (x < -charW || x > w + charW) continue;
    const wobble = sin(t * 6 + i * 60) * 8;
    const r = 230 + sin(t * 3 + i * 40) * 25 | 0;
    const g = 210 + sin(t * 2 + i * 50 + 300) * 45 | 0;
    const b = 255;
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillText(scrollText[i], x, scrollY + wobble);
  }
  scrollX -= 2;
  if (scrollX < -scrollText.length * charW) scrollX = w;
}

// Raster bars behind logo
function drawRasterBars() {
  const cy = h / 2;
  for (let i = -40; i < 40; i++) {
    const y = cy + i * 3;
    const intensity = 1 - Math.abs(i) / 40;
    const r = sin(t * 2 + i * 30) * 30 * intensity | 0;
    const g = sin(t * 2.5 + i * 40 + 200) * 20 * intensity | 0;
    const b = sin(t * 3 + i * 50 + 500) * 40 * intensity | 0;
    ctx.fillStyle = `rgba(${80 + r},${40 + g},${90 + b},${intensity * 0.3})`;
    ctx.fillRect(0, y, w, 3);
  }
}

// --- 8-bit music engine (Second Reality inspired) ---
let audioStarted = false;
function startAudio() {
  if (audioStarted) return;
  audioStarted = true;
  const ac = new (window.AudioContext || window.webkitAudioContext)();
  const master = ac.createGain();
  master.gain.value = 0.35;
  master.connect(ac.destination);

  // note freq helper
  const noteFreq = n => 440 * Math.pow(2, (n - 69) / 12);

  // D minor scale: D E F G A Bb C
  // Pattern in MIDI notes
  const bpm = 135;
  const step = 60 / bpm / 4; // 16th note

  // Bass line (triangle-ish) - dark, driving, octave jumps
  const bass = [
    38,38,50,38, 38,38,50,38, 41,41,53,41, 41,41,53,41,
    43,43,55,43, 43,43,55,43, 41,41,53,41, 41,41,53,41,
  ];

  // Arpeggio pattern (square wave) - minor chords
  const arp = [
    62,65,69,72, 62,65,69,72, 65,69,72,74, 65,69,72,74,
    67,70,74,77, 67,70,74,77, 65,69,72,74, 65,69,72,74,
  ];

  // Melody (pulse wave) - atmospheric
  const mel = [
    74,-1,72,69, 74,-1,77,74, 72,-1,69,65, 69,-1,67,-1,
    70,-1,69,67, 70,-1,74,72, 69,-1,67,65, 67,-1,62,-1,
  ];

  // Drums: 1=kick, 2=snare, 3=hihat
  const drums = [
    1,3,0,3, 2,3,0,3, 1,3,1,3, 2,3,0,3,
    1,3,0,3, 2,3,0,3, 1,3,1,3, 2,0,2,3,
  ];

  const patLen = bass.length;
  const loopDur = patLen * step;

  function playNote(freq, start, dur, type, gain, detune) {
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type;
    o.frequency.value = freq;
    if (detune) o.detune.value = detune;
    g.gain.setValueAtTime(gain, start);
    g.gain.exponentialRampToValueAtTime(0.001, start + dur);
    o.connect(g);
    g.connect(master);
    o.start(start);
    o.stop(start + dur);
  }

  function playNoise(start, dur, gain) {
    const buf = ac.createBuffer(1, ac.sampleRate * dur, ac.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
    const s = ac.createBufferSource();
    s.buffer = buf;
    const g = ac.createGain();
    g.gain.setValueAtTime(gain, start);
    g.gain.exponentialRampToValueAtTime(0.001, start + dur);
    s.connect(g);
    g.connect(master);
    s.start(start);
    s.stop(start + dur);
  }

  function scheduleLoop(loopStart) {
    for (let i = 0; i < patLen; i++) {
      const t0 = loopStart + i * step;

      // Bass
      if (bass[i] > 0) playNote(noteFreq(bass[i]), t0, step * 0.9, 'triangle', 0.5, 0);

      // Arp
      if (arp[i] > 0) playNote(noteFreq(arp[i]), t0, step * 0.4, 'square', 0.12, 8);

      // Melody
      if (mel[i] > 0) playNote(noteFreq(mel[i]), t0, step * 1.5, 'square', 0.1, -6);

      // Drums
      if (drums[i] === 1) { // kick
        playNote(55, t0, 0.15, 'sine', 0.6, 0);
        playNote(110, t0, 0.05, 'sine', 0.3, 0);
      } else if (drums[i] === 2) { // snare
        playNoise(t0, 0.1, 0.25);
        playNote(180, t0, 0.05, 'triangle', 0.2, 0);
      } else if (drums[i] === 3) { // hihat
        playNoise(t0, 0.04, 0.1);
      }
    }
  }

  let nextLoop = ac.currentTime + 0.05;
  function scheduler() {
    while (nextLoop < ac.currentTime + 0.5) {
      scheduleLoop(nextLoop);
      nextLoop += loopDur;
    }
    setTimeout(scheduler, 200);
  }
  scheduler();
}

document.addEventListener('click', startAudio, { once: true });
document.addEventListener('keydown', startAudio, { once: true });

function frame() {
  t++;
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, w, h);

  if (!audioStarted) {
    ctx.fillStyle = 'rgba(255,255,255,' + (0.4 + Math.sin(t * 0.05) * 0.3) + ')';
    ctx.font = '16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('CLICK TO START', w / 2, h * 0.06);
    ctx.textAlign = 'left';
  }

  drawPlasma();
  drawStars();
  drawCopper();
  drawRasterBars();
  drawLogo();
  drawScroller();

  requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>
